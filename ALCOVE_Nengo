# -*- coding: utf-8 -*-
"""
Created on Thu Nov 19 12:35:44 2015

@author: Art_Rich
"""

#%%

""" Libraries """

import numpy as np
import nengo
from matplotlib.pyplot import *

""" Parameters """

n_neurons = 300
n_dims = 3
n_cats = 1
n_stims = 8
t_stim = 2
lr_ro = 3e-4
n_runs = 1

features = np.zeros([n_stims, n_dims])
features[::2,0] = 1
features[:2,1] = 1
features[4:6,1] = 1
features[:4,2] = 1
features = np.tile(features.T, n_runs + 2).T
classes = np.zeros((n_stims,1))
classes = np.tile(classes.T, n_runs + 2).T
classes[features[:,0] == features[:,2]] = 1

trans = np.ones((1,n_dims))

""" Functions """

def inp(t):
    ind = np.int(t/t_stim)
    return features[ind,:]

def teach(t):
    ind = np.int(t/t_stim)
    return classes[ind,:]

class set_weights(nengo.solvers.Solver):
    def __init__(self, wMtrx, weights = True):
        self.weights = weights
        self.decoders = wMtrx.T

    def __call__(self, A, Y, E=None, rng=None):
        return self.decoders, []
        
#%%

""" Network Setup """

model = nengo.Network()

with model:
    
    # Basic Ensembles
    I = nengo.Ensemble(n_neurons = n_neurons, dimensions = n_dims)
    O = nengo.Ensemble(n_neurons = n_neurons, dimensions = n_cats)
    E = nengo.Ensemble(n_neurons = n_neurons, dimensions = n_cats, radius = 3)
    C = nengo.Ensemble(n_neurons = n_neurons, dimensions = n_cats)
    
    # Input Nodes
    p_inp = nengo.Node(output = inp)
    p_teach = nengo.Node(output = teach)
    
    # Feed Inout into Network
    nengo.Connection(p_inp, I)
    nengo.Connection(p_teach, C)
    
    # Learn Output weights
    conn = nengo.Connection(I, O, transform = trans, solver = set_weights(np.random.rand(n_neurons, n_neurons)))
    nengo.Connection(O, E, transform = -1)
    nengo.Connection(C, E)
    error_conn = nengo.Connection(E, O, modulatory = True)
    conn.learning_rule_type = nengo.PES(error_connection = error_conn, learning_rate = lr_ro)
    
    # shut-off learning
    stop_learning = nengo.Node(output=lambda t: t >= n_stims * t_stim * n_runs)
    nengo.Connection(stop_learning, E.neurons, transform = -20 * np.ones((E.n_neurons, 1)))
    
#%%
    
""" Run Model """

with model:
    
    # collect probes
    E_probe = nengo.Probe(E)
    I1_probe = nengo.Probe(I[0])
    I2_probe = nengo.Probe(I[1])
    I3_probe = nengo.Probe(I[2])
    O_probe = nengo.Probe(O)
    C_probe = nengo.Probe(C)
    teach_probe = nengo.Probe(p_teach)
    
# run simulation
sim = nengo.Simulator(model)
t_sim = n_runs * n_stims * t_stim + 1
T = 15
sim.run(t_sim)

#%%

""" transform O activation into category decisions """

signal = np.squeeze(sim.data[O_probe])
real_classes = np.squeeze(sim.data[teach_probe])
window = t_stim * 1000

#kernel = np.zeros(30)
#kernel[10:20] = 1
#signal_smoothed = np.convolve(signal,kernel)
#
#choice = np.zeros((len(signal),1))
#choice[signal_smoothed[0:len(signal)] > 7.0] = 1

choice_final = np.zeros(n_runs * n_stims)
for i in range(n_runs * n_stims):
    test = np.mean(signal[i*window : (i+1)*window])
    choice_final[i] = 1 if test > 0.8 else 0

#%%

""" Compute classification error """

error = np.mean(np.abs(np.squeeze(classes[0:n_runs*n_stims]) - choice_final))

#%%

""" Plotting """
# Plotting
figure(figsize=(9, 9))
subplot(3, 1, 1)
plot(sim.trange(), sim.data[C_probe], label='Real Classes', color='k', linewidth=2.0)
plot(sim.trange(), signal, label='Network Output', color='r', linewidth=2.0)
legend(loc='lower right')
ylim(-3.2, 3.2)

subplot(3, 1, 2)
plot(sim.trange(), sim.data[I1_probe], label='Input Dim 1', linewidth=2.0)
plot(sim.trange(), sim.data[I2_probe], label='Input Dim 2', linewidth=2.0)
plot(sim.trange(), sim.data[I3_probe], label='Input Dim 3', linewidth=2.0)
legend(loc='lower right')
ylim(-3.2, 3.2)

subplot(3, 1, 3)
plot(sim.trange(), sim.data[E_probe], label='Error Ensemble')
plot(sim.trange(), sim.data[O_probe] - sim.data[C_probe], label='Error Real')
legend(loc='lower right')
tight_layout();
    
    
